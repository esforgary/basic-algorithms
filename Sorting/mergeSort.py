from random import uniform

def mergeSort(nums): 
  if len(nums) > 1: 
    mid = len(nums) // 2                      # Наш первый шаг — разделить список надвое. Мы будем использовать целочисленное деление,
    right = nums[mid:]                        # чтобы в итоге получить целый индекс. Затем мы создадим два меньших списка, left и right. 
    left = nums[:mid]                         # Для этого мы используем очень удобную нотацию Python для подсписков.
    mergeSort(left)                           # отсортируем обе половины, вызывая для них merge_sort().
    mergeSort(right) 
    i = j = k = 0                             # i — индекс в списке left, j — индекс в списке right, k — индекс в исходном списке nums, в который в конечном итоге нужно вставить все числа по порядку.

    while i < len(left) and j < len(right):   # После этого мы будем перебирать и левый, и правый список, сравнивая каждый элемент.
      if left[i] < right[j]:                  # Пройти списки необходимо только один раз, потому что left и right уже отсортированы.
        nums[k] = left[i]                     # Нам нужно только соединить их.
        i += 1
      else:                                   # Если число из списка left меньше, чем число из списка right, мы вставляем его в nums на позицию
        nums[k] = right[j]                    # k, после чего увеличиваем индекс i на единицу. Если число из списка right меньше или равно числу из
        j += 1                                # списка left, тогда оно отправляется в nums, а мы увеличиваем на единицу индекс j. Наконец, после
      k += 1                                  # добавления любого из чисел в список nums, мы увеличиваем на единицу индекс k.

    while i < len(left):                      # Но нужно еще кое-что сделать. Мы написали while i < len(left) and j < len(right), то есть, если эти
      nums[k] = left[i]                       # условия выполняются, цикл прерывается. Но что, если мы дойдем до конца списка left, а в списке right
      i += 1                                  # еще останутся элементы? На этот случай нам нужно сделать еще один цикл while. В этом цикле мы будем
      k += 1                                  # перебирать остаток элементов в списке right и добавлять их в список nums. То же самое мы сделаем и для списка left.

    while j < len(right): 
      nums[k] = right[j] 
      j += 1
      k += 1

def main():	
  try:
    array = [round(uniform(-100, 100), 2) for i in range(100)]

    print(array)
    mergeSort(array)    
    print(f"\nОтсортированный масив: \n{array}")

  except:    
    print("\nНеверные данные !!!\n")

if __name__ == "__main__":
	main() 